{"title":"Creating an Advent of Code Application Using Go Plugins","markdown":{"yaml":{"title":"Creating an Advent of Code Application Using Go Plugins","date":"2019-10-08T17:53:49-04:00","categories":["go","advent of code","bash","puzzle"],"description":"I've always enjoyed solving puzzles, and love coding puzzles. This post walks through how I have set up my Advent of Code project using Go Plugins for different days' solutions. No spoilers!"},"headingText":"Go Plugins","containsRefs":false,"markdown":"\n\nThe best way to learn programming is to write code. The advice is almost always \"build something,\" but it can be hard to figure out what a good \"something\" would be, especially for beginners. In my mind, that's where coding puzzles come in. Some of my favorites are [Advent of Code](https://adventofcode.com), [Project Euler](https://www.projecteuler.net) (for the more mathematically inclined) and [Rosalind](http://rosalind.info/problems/locations) (focused on bioinformatics). I've spent a fair bit of time working through Advent of Code puzzles in a few different languages -- R, Python, Julia, and Go so far. I can't say that I've completed all 25 challenges for a year, nor that I've done all four of those languages for every puzzle that I've completed. But I've gotten a tremendous amount of enjoyment and satisfaction from doing the puzzles that I have worked on, and I've learned a ton.\n\nIn this post, I'm going to talk about how I have structured my Go solutions (later posts will get into the puzzle solutions themselves in detail). I really wanted to embed my solutions in a single application and have everything runnable through a common command. I found the Go [Plugin package](https://golang.org/pkg/plugin) to be just about the best solution for doing this, though not without its challenges. Most things I read about the plugin package said that it wasn't mature enough, or that it's too clunky to work well. While it definitely is a little clunky, I think it does alright for this job.\n\nThe main challenge that I was facing was how to dynamically include different Go source files for execution from a main program. I wanted to specify at runtime which package to import and run, which is not possible as far as I know. I didn't want to run the solution code, write the answers to disk, and then have the main program just read in those answers. The other solution that I had come across was to create a map with dates pointing to solution functions. I definitely thought about how I might do that, but decided that manually importing every solution file and filling in the map with the functions from each file was just too much of a pain, and not a very elegant solution.\n\n\nSo what exactly is a Go plugin? From the package docs:\n\n> A plugin is a Go main package with exported functions and variables that have been built with:\n\n```         \ngo build -buildmode=plugin\n```\n\nImportantly, even though a Go plugin is a `main` package, *the `main()` function is not run*. This is nice because it can allow you to export functionality from a `main` package that you may have written for some other purpose. But it is a pain because Go will not compile a `main` package without a `main()` function, so you still need one even if you're creating a package specifically to be a plugin, and you know you won't actually use `main()`. The other irritating part is that you have to provide type information to the caller program about the entities from the plugin that you want to use. I was able to make this work by having every plugin implement a function with the signature `func Solve(fname string)`, which takes the path to the problem input as its argument, runs the solution functions, and prints the answers. That way, I can have the same code in my main program regardless of the intermediate steps involved in any given day's solution.\n\n## Program Structure\n\n*You can find the full source code on [GitHub](https://github.com/stephenfeagin/Go-AdventOfCode)*.\n\nSo given this brief overview of Go plugins, how does it work in practice? The project has this overall file structure:\n\n```         \n.\n|__ AOC.go\n|__ puzzles/\n|  |__ 2018/\n|  |  |__ 01/\n|  |  |  |__ input.txt\n|  |  |  |__ main.go\n```\n\n`AOC.go` is the main Advent of Code program file. It includes the code to load plugins and execute the solution function from those plugins. The `puzzles/` directory contains sub-directories for each day's puzzle, where `input.txt` is the puzzle input (generated for each unique user of adventofcode.com) and `main.go` contains the source code for the solutions.\n\nAs mentioned above, all of the `main.go` solution files contain a function with the signature `func Solve(fname string)`. Beyond that, they also generally contain a `func readInput(fname string)` as well as functions for the different parts of the puzzle, taking in the data structure(s) produced by `readInput()`. They also all contain a blank `func main(){}` so that they can be compiled as `main` packages, as required by the `plugin` package. For any puzzle solution, we have to compile it as a plugin to provide a `.so` file with a predictable name that the `AOC.go` file can locate and access. To do this, we run:\n\n``` bash\n$ cd puzzles/$YEAR/$DAY\n$ go build -buildmode=plugin -o $YEAR$DAY.so\n```\n\n`AOC.go` is the most interesting file as far as the plugin system is concerned. After reading in the year and day for the desired puzzle, it has to attempt to locate a solution directory and `.so` (shared object) file for that date:\n\n``` go\nimport (\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"plugin\"\n)\n\ndir := filepath.Join(\"puzzles\", year, day)\n// Check for solution directory\nif s, err := os.Stat(dir); os.IsNotExist(err) || !s.IsDir() {\n    fmt.Println(\"No solution available for\", year, day)\n    os.Exit(1)\n}\n// Check for .so file\npluginPath := filepath.Join(dir, year+day+\".so\")\np, err := plugin.Open(pluginPath)\nif err != nil {\n    fmt.Printf(\"No such file %s.so\\n\", year+day)\n    os.Exit(1)\n}\n```\n\nAssuming that our program survives through that point (i.e. we have the correct subdirectory inside the `puzzles/` directory and that we have compiled it with `-buildmode=plugin` to create a `.so` file), we then need to find the `Solve()` function and run it. We need to know the name of the symbol that we're looking up, as well as its type/signature.\n\n``` go\nsymbol, err := p.Lookup(\"Solve\")\nif err != nil {\n    fmt.Println(err.Error())\n    os.Exit(1)\n}\n\nsolve, ok := symbol.(func(string))\nif !ok {\n    fmt.Println(\"Plugin has no 'Solve' function\")\n    os.Exit(1)\n}\n```\n\nAll that's left is to provide the path to the puzzle's input file and run the `Solve()` function.\n\n``` go\ninputFile := filepath.Join(dir, \"input.txt\")\nsolve(inputFile)\n```\n\nI have set things up so that the `Solve()` functions print out the answers, rather than returning them as a string. So once we call `solve()` in the parent program, we're all done! Running from the command line is as easy as\n\n``` bash\n$ go build -o AOC\n$ ./AOC 2018 1\n```\n\n## Helper Scripts\n\nIt would definitely get tedious to create new solution directories by hand, write the solution code, then compile it with the `-buildmode=plugin` flag by hand. Especially when it turns out that the solution needs to be fixed or refactored, and then needs to be compiled yet again. So I created a couple of different helper scripts to make these tasks a little easier.\n\n### `new_puzzle.sh`\n\nWhen I want to start working on a new solution, I like having a template for the files ready to go. In the project root, I have a directory called `template` containing `input.txt.templ`, which is blank (the input is taken from the AOC website), and `main.go.templ` which contains a skeleton file with `func Solve(fname string)`, `func ReadInput(fname string)`, `func Part1()`, and `func Part2()`, as well as the empty `func main(){}`. `new_puzzle.sh` copies the basic templates into a new directory for the year and day that I want to solve. After doing some input validation (which I won't get into here), the main part of the script creates the directory, creates a basic `README.md`, and copies over a couple of templates for the source code and the input file.\n\n``` bash\nYEAR=$1\nDAY=$2\n\nDIR=\"puzzles/$YEAR/$DAY\"\nmkdir -p $DIR\ncp template/input.txt.templ $DIR/input.txt\ncp template/main.go.templ $DIR/main.go\n\nREADME=\"# [$YEAR Day $DAY:](https://adventofcode.com/$YEAR/day/$DAY)\\n\\n\"\necho -e $README > $DIR/README.md\n```\n\n### `build_plugin.sh`\n\nIt's also nice to be able to build a plugin from the project root, without worrying about changing directories, making sure the `.so` file is in the right place, and typing everything out by hand. Once again skipping over input validation in this post, the script is fairly straightforward:\n\n``` bash\nYEAR=$1\nDAY=$2\nDIR=\"puzzles/$YEAR/$DAY\"\n\nif [[ -d $DIR ]]; then\n    cd $DIR\n    go build -buildmode=plugin -o $YEAR$DAY.so\nelse\n    echo \"$DIR does not exist\"\n    exit 1\nfi\n```\n\n### `build_all_plugins.sh`\n\nFinally, it's sometimes helpful to be able to compile every plugin you've got, instead of just one at a time. This is especially useful after cloning the git repository, since the `.so` files are ignored. This was a great opportunity for me to learn more about control flow in bash. Again, it's not a very complex script, but I find it incredibly useful.\n\n``` bash\ncd puzzles\n\n# every subdir in puzzles/ is a year\nfor YEAR in *; do\n    # cd into the year's dir\n    cd $YEAR\n    echo \"$YEAR\"\n\n    # every subdir in puzzles/$YEAR/ is a day\n    for DAY in *; do\n        # cd into day's dir\n        cd $DAY\n        echo -e \"\\t$DAY\"\n\n        # if there's a main.go file, build it\n        if [[ -f main.go ]]; then\n            go build -buildmode=plugin -o $YEAR$DAY.so\n        fi\n\n        # cd back into the year dir\n        cd ..\n    done\ndone\n```\n\n## Conclusion\n\nGo's plugin system does have a lot of restrictions -- it's only available on MacOS and Linux, it requires the plugin and the caller program to be compiled with the exact same version of Go and of any dependencies that are be imported in both, etc. But if you are working solo or if the plugins and the calling program will be built on the same machine at roughly the same time, it's not a bad solution. My Advent of Code use case is obviously not the most complex or technically demanding application, so I can't speak to the usefulness of Go plugins in other contexts. But I've enjoyed working with them and have learned a lot from the experience. If it looks like the plugin package might be useful for you, I'd strongly encourage you to give it a try!\n\n## Resources\n\n-   [Advent of Code](https://adventofcode.com)\n-   [GitHub Repository](https://github.com/stephenfeagin/Go-AdventOfCode) for my Advent of Code project\n-   Go [Plugin package documentation](https://golang.org/pkg/plugin/)\n-   Vladimir Viven, [\"Writing Modular Go Programs with Plugins\"](https://medium.com/learning-the-go-programming-language/writing-modular-go-programs-with-plugins-ec46381ee1a9)\n","srcMarkdownNoYaml":"\n\nThe best way to learn programming is to write code. The advice is almost always \"build something,\" but it can be hard to figure out what a good \"something\" would be, especially for beginners. In my mind, that's where coding puzzles come in. Some of my favorites are [Advent of Code](https://adventofcode.com), [Project Euler](https://www.projecteuler.net) (for the more mathematically inclined) and [Rosalind](http://rosalind.info/problems/locations) (focused on bioinformatics). I've spent a fair bit of time working through Advent of Code puzzles in a few different languages -- R, Python, Julia, and Go so far. I can't say that I've completed all 25 challenges for a year, nor that I've done all four of those languages for every puzzle that I've completed. But I've gotten a tremendous amount of enjoyment and satisfaction from doing the puzzles that I have worked on, and I've learned a ton.\n\nIn this post, I'm going to talk about how I have structured my Go solutions (later posts will get into the puzzle solutions themselves in detail). I really wanted to embed my solutions in a single application and have everything runnable through a common command. I found the Go [Plugin package](https://golang.org/pkg/plugin) to be just about the best solution for doing this, though not without its challenges. Most things I read about the plugin package said that it wasn't mature enough, or that it's too clunky to work well. While it definitely is a little clunky, I think it does alright for this job.\n\nThe main challenge that I was facing was how to dynamically include different Go source files for execution from a main program. I wanted to specify at runtime which package to import and run, which is not possible as far as I know. I didn't want to run the solution code, write the answers to disk, and then have the main program just read in those answers. The other solution that I had come across was to create a map with dates pointing to solution functions. I definitely thought about how I might do that, but decided that manually importing every solution file and filling in the map with the functions from each file was just too much of a pain, and not a very elegant solution.\n\n## Go Plugins\n\nSo what exactly is a Go plugin? From the package docs:\n\n> A plugin is a Go main package with exported functions and variables that have been built with:\n\n```         \ngo build -buildmode=plugin\n```\n\nImportantly, even though a Go plugin is a `main` package, *the `main()` function is not run*. This is nice because it can allow you to export functionality from a `main` package that you may have written for some other purpose. But it is a pain because Go will not compile a `main` package without a `main()` function, so you still need one even if you're creating a package specifically to be a plugin, and you know you won't actually use `main()`. The other irritating part is that you have to provide type information to the caller program about the entities from the plugin that you want to use. I was able to make this work by having every plugin implement a function with the signature `func Solve(fname string)`, which takes the path to the problem input as its argument, runs the solution functions, and prints the answers. That way, I can have the same code in my main program regardless of the intermediate steps involved in any given day's solution.\n\n## Program Structure\n\n*You can find the full source code on [GitHub](https://github.com/stephenfeagin/Go-AdventOfCode)*.\n\nSo given this brief overview of Go plugins, how does it work in practice? The project has this overall file structure:\n\n```         \n.\n|__ AOC.go\n|__ puzzles/\n|  |__ 2018/\n|  |  |__ 01/\n|  |  |  |__ input.txt\n|  |  |  |__ main.go\n```\n\n`AOC.go` is the main Advent of Code program file. It includes the code to load plugins and execute the solution function from those plugins. The `puzzles/` directory contains sub-directories for each day's puzzle, where `input.txt` is the puzzle input (generated for each unique user of adventofcode.com) and `main.go` contains the source code for the solutions.\n\nAs mentioned above, all of the `main.go` solution files contain a function with the signature `func Solve(fname string)`. Beyond that, they also generally contain a `func readInput(fname string)` as well as functions for the different parts of the puzzle, taking in the data structure(s) produced by `readInput()`. They also all contain a blank `func main(){}` so that they can be compiled as `main` packages, as required by the `plugin` package. For any puzzle solution, we have to compile it as a plugin to provide a `.so` file with a predictable name that the `AOC.go` file can locate and access. To do this, we run:\n\n``` bash\n$ cd puzzles/$YEAR/$DAY\n$ go build -buildmode=plugin -o $YEAR$DAY.so\n```\n\n`AOC.go` is the most interesting file as far as the plugin system is concerned. After reading in the year and day for the desired puzzle, it has to attempt to locate a solution directory and `.so` (shared object) file for that date:\n\n``` go\nimport (\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"plugin\"\n)\n\ndir := filepath.Join(\"puzzles\", year, day)\n// Check for solution directory\nif s, err := os.Stat(dir); os.IsNotExist(err) || !s.IsDir() {\n    fmt.Println(\"No solution available for\", year, day)\n    os.Exit(1)\n}\n// Check for .so file\npluginPath := filepath.Join(dir, year+day+\".so\")\np, err := plugin.Open(pluginPath)\nif err != nil {\n    fmt.Printf(\"No such file %s.so\\n\", year+day)\n    os.Exit(1)\n}\n```\n\nAssuming that our program survives through that point (i.e. we have the correct subdirectory inside the `puzzles/` directory and that we have compiled it with `-buildmode=plugin` to create a `.so` file), we then need to find the `Solve()` function and run it. We need to know the name of the symbol that we're looking up, as well as its type/signature.\n\n``` go\nsymbol, err := p.Lookup(\"Solve\")\nif err != nil {\n    fmt.Println(err.Error())\n    os.Exit(1)\n}\n\nsolve, ok := symbol.(func(string))\nif !ok {\n    fmt.Println(\"Plugin has no 'Solve' function\")\n    os.Exit(1)\n}\n```\n\nAll that's left is to provide the path to the puzzle's input file and run the `Solve()` function.\n\n``` go\ninputFile := filepath.Join(dir, \"input.txt\")\nsolve(inputFile)\n```\n\nI have set things up so that the `Solve()` functions print out the answers, rather than returning them as a string. So once we call `solve()` in the parent program, we're all done! Running from the command line is as easy as\n\n``` bash\n$ go build -o AOC\n$ ./AOC 2018 1\n```\n\n## Helper Scripts\n\nIt would definitely get tedious to create new solution directories by hand, write the solution code, then compile it with the `-buildmode=plugin` flag by hand. Especially when it turns out that the solution needs to be fixed or refactored, and then needs to be compiled yet again. So I created a couple of different helper scripts to make these tasks a little easier.\n\n### `new_puzzle.sh`\n\nWhen I want to start working on a new solution, I like having a template for the files ready to go. In the project root, I have a directory called `template` containing `input.txt.templ`, which is blank (the input is taken from the AOC website), and `main.go.templ` which contains a skeleton file with `func Solve(fname string)`, `func ReadInput(fname string)`, `func Part1()`, and `func Part2()`, as well as the empty `func main(){}`. `new_puzzle.sh` copies the basic templates into a new directory for the year and day that I want to solve. After doing some input validation (which I won't get into here), the main part of the script creates the directory, creates a basic `README.md`, and copies over a couple of templates for the source code and the input file.\n\n``` bash\nYEAR=$1\nDAY=$2\n\nDIR=\"puzzles/$YEAR/$DAY\"\nmkdir -p $DIR\ncp template/input.txt.templ $DIR/input.txt\ncp template/main.go.templ $DIR/main.go\n\nREADME=\"# [$YEAR Day $DAY:](https://adventofcode.com/$YEAR/day/$DAY)\\n\\n\"\necho -e $README > $DIR/README.md\n```\n\n### `build_plugin.sh`\n\nIt's also nice to be able to build a plugin from the project root, without worrying about changing directories, making sure the `.so` file is in the right place, and typing everything out by hand. Once again skipping over input validation in this post, the script is fairly straightforward:\n\n``` bash\nYEAR=$1\nDAY=$2\nDIR=\"puzzles/$YEAR/$DAY\"\n\nif [[ -d $DIR ]]; then\n    cd $DIR\n    go build -buildmode=plugin -o $YEAR$DAY.so\nelse\n    echo \"$DIR does not exist\"\n    exit 1\nfi\n```\n\n### `build_all_plugins.sh`\n\nFinally, it's sometimes helpful to be able to compile every plugin you've got, instead of just one at a time. This is especially useful after cloning the git repository, since the `.so` files are ignored. This was a great opportunity for me to learn more about control flow in bash. Again, it's not a very complex script, but I find it incredibly useful.\n\n``` bash\ncd puzzles\n\n# every subdir in puzzles/ is a year\nfor YEAR in *; do\n    # cd into the year's dir\n    cd $YEAR\n    echo \"$YEAR\"\n\n    # every subdir in puzzles/$YEAR/ is a day\n    for DAY in *; do\n        # cd into day's dir\n        cd $DAY\n        echo -e \"\\t$DAY\"\n\n        # if there's a main.go file, build it\n        if [[ -f main.go ]]; then\n            go build -buildmode=plugin -o $YEAR$DAY.so\n        fi\n\n        # cd back into the year dir\n        cd ..\n    done\ndone\n```\n\n## Conclusion\n\nGo's plugin system does have a lot of restrictions -- it's only available on MacOS and Linux, it requires the plugin and the caller program to be compiled with the exact same version of Go and of any dependencies that are be imported in both, etc. But if you are working solo or if the plugins and the calling program will be built on the same machine at roughly the same time, it's not a bad solution. My Advent of Code use case is obviously not the most complex or technically demanding application, so I can't speak to the usefulness of Go plugins in other contexts. But I've enjoyed working with them and have learned a lot from the experience. If it looks like the plugin package might be useful for you, I'd strongly encourage you to give it a try!\n\n## Resources\n\n-   [Advent of Code](https://adventofcode.com)\n-   [GitHub Repository](https://github.com/stephenfeagin/Go-AdventOfCode) for my Advent of Code project\n-   Go [Plugin package documentation](https://golang.org/pkg/plugin/)\n-   Vladimir Viven, [\"Writing Modular Go Programs with Plugins\"](https://medium.com/learning-the-go-programming-language/writing-modular-go-programs-with-plugins-ec46381ee1a9)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","editor":"visual","theme":"cosmo","title-block-banner":false,"title":"Creating an Advent of Code Application Using Go Plugins","date":"2019-10-08T17:53:49-04:00","categories":["go","advent of code","bash","puzzle"],"description":"I've always enjoyed solving puzzles, and love coding puzzles. This post walks through how I have set up my Advent of Code project using Go Plugins for different days' solutions. No spoilers!"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}