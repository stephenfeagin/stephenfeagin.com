{"title":"Adventures in Data Cleaning","markdown":{"yaml":{"title":"Adventures in Data Cleaning","author":"Stephen Feagin","date":"2019-04-28","categories":["r","tidyverse","data cleaning"]},"headingText":"Loading Data","containsRefs":false,"markdown":"\n\n```{r include=FALSE}\nknitr::opts_chunk$set(message = FALSE)\n```\n\nI'm updating my first R-related blog post, from back in 2016. In it, I used reshape2 to do some data cleaning on a messy dataset. In this update, I'm going to use tools from the tidyverse instead. I'm keeping most of the text the same, but changing the code chunks. As before, this is an R Markdown file, so you can run the code along with me. You can find the data source [here](data/datastream_excerpt.xlsx).\n\nI've been working with stock market data, which has proven much less straightforward than I had expected. Because the data I want is both cross-sectional and time-series --- it uses daily data on multiple values for multiple companies over a length of time --- the raw data is an absolute mess. I got the dataset from Thomson Reuters Datastream, which was a process in and of itself. So in this post, I'm just going to walk through the steps involved in cleaning the data into a workable data file.\n\nThere are a couple of packages I'll be using: readxl for reading in the Excel-formatted data, tidyr and dplyr for data cleaning, and here for dealing with filepaths in the website directoryt tree (you may not need to deal with that, though). The only one that I want to import into the global namespace is dplyr, because I only use the others once or twice.\n\n```{r}\nlibrary(dplyr)\n```\n\n\nEasy enough:\n\n```{r}\nfilepath <- \"datastream_excerpt.xlsx\"\ndat <- readxl::read_excel(filepath)\n```\n\nLet's see how that looks in its original format:\n\n```{r}\ndat\n```\n\nNone of these entries are entirely clear from just looking at the data. The first column, here called Name, is the numerical representation of the date for that entry. The second column gives us the adjusted share price for the company Abbott Labs, and the third shows the market value. The spreadsheet doesn't actually indicate that the second column is the price, but I know that I downloaded only the share price and market value for each company. We can also see that there are a number of columns that Datastream failed to produce data for, showing up as #ERROR.\n\n## Dropping Invalid Columns\n\nThe first step is to remove the #ERROR columns. I do this using the dplyr::select_at() function, which allows me to search for character strings within column names. I redefine my dat object as the original dataframe, minus any column whose name contains \"ERROR.\"\n\n```{r}\ndat <- select_at(dat, vars(-starts_with(\"#ERROR\")))\n```\n\nWhile I'm at it, I'm going to rename the columns to all lowercase letters. Just for convenience, not necessary. I'm also going to change the name of the first column from name to date. dplyr::rename_all() is similar to dplyr::select_at(), except that I don't have to specify a rule for determining which columns to include, and I add the function that I want applied to all of the column names.\n\n```{r}\ndat <- dat %>% \n  rename_all(tolower) %>% \n  rename(date = name)\n```\n\nLet's take a look at the table now:\n\n```{r}\ndat\n```\n\nMuch better.\n\n## Reshaping\n\nNow that we've cleaned up the column names, we can move onto the real problem: the shape of the dataset. This is where tidyr comes in. tidyr provides functions to transform long tables into wide ones, and vice-versa. We currently have a dataset with a row for each day, and seaparate columns for each variable (share price and market value), grouped into companies. We want to end up with a dataset with a row for each company-day, and a column for each variable. That is, I want a column for date, a column for company, a column for price, and a column for market_value. The number of rows should equal the number of companies multipled by the number of unique days in the dataset. Here is my general approach:\n\n1.  Split the dataset into share price and market value tables\n2.  Convert both tables into \"long\" format\n3.  Join them back together by company name and date\n\n### Spliting the Data\n\nFirst, we need to split the dataset into two different tables, one for share price and one for market value.\n\n```{r}\nshare_price <- select_at(dat, vars(-ends_with(\"market value\")))\nmarket_value <- select_at(dat, vars(date, ends_with(\"value\")))\n```\n\nHere's the share_price table:\n\n```{r}\nshare_price\n```\n\nAnd the market_value table:\n\n```{r}\nmarket_value\n```\n\n### Lengthening the Tables\n\nNext, we use the tidyr::gather() function to turn the very wide tables into long ones.\n\n```{r}\nshare_price <- tidyr::gather(share_price, key = \"company\", value = \"share_price\", -date)\nmarket_value <- tidyr::gather(market_value, key = \"company\", value = \"market_value\", -date)\n```\n\ngather() takes a key argument, which is the name of the column in the new table that has all of the column names from the old table, and a value argument, which is the name of the column in the new table that actually contains the data. We also include -date to let the function know that we do not want the date field to be collapsed, we want it excluded from the operation.\n\nHere's the share_price data now:\n\n```{r}\nshare_price\n```\n\nAnd market_value:\n\n```{r}\nmarket_value\n```\n\nWhile I still have the data split, I'm going to clean up the company field in the market_value table so that it only has the company name.\n\n```{r}\nmarket_value <- mutate(market_value, company = gsub(\" - market value\", \"\", company))\nmarket_value\n```\n\n### Re-Combining\n\nNow all that's left is to join the tables back together. dplyr provides a number of \\_join() functions that mirror SQL joins, so the operation is pretty intuitive if you've worked with database tables.\n\n```{r}\nnew_data <- full_join(share_price, market_value, by = c(\"date\", \"company\"))\nnew_data\n```\n\nBeautiful.\n","srcMarkdownNoYaml":"\n\n```{r include=FALSE}\nknitr::opts_chunk$set(message = FALSE)\n```\n\nI'm updating my first R-related blog post, from back in 2016. In it, I used reshape2 to do some data cleaning on a messy dataset. In this update, I'm going to use tools from the tidyverse instead. I'm keeping most of the text the same, but changing the code chunks. As before, this is an R Markdown file, so you can run the code along with me. You can find the data source [here](data/datastream_excerpt.xlsx).\n\nI've been working with stock market data, which has proven much less straightforward than I had expected. Because the data I want is both cross-sectional and time-series --- it uses daily data on multiple values for multiple companies over a length of time --- the raw data is an absolute mess. I got the dataset from Thomson Reuters Datastream, which was a process in and of itself. So in this post, I'm just going to walk through the steps involved in cleaning the data into a workable data file.\n\nThere are a couple of packages I'll be using: readxl for reading in the Excel-formatted data, tidyr and dplyr for data cleaning, and here for dealing with filepaths in the website directoryt tree (you may not need to deal with that, though). The only one that I want to import into the global namespace is dplyr, because I only use the others once or twice.\n\n```{r}\nlibrary(dplyr)\n```\n\n## Loading Data\n\nEasy enough:\n\n```{r}\nfilepath <- \"datastream_excerpt.xlsx\"\ndat <- readxl::read_excel(filepath)\n```\n\nLet's see how that looks in its original format:\n\n```{r}\ndat\n```\n\nNone of these entries are entirely clear from just looking at the data. The first column, here called Name, is the numerical representation of the date for that entry. The second column gives us the adjusted share price for the company Abbott Labs, and the third shows the market value. The spreadsheet doesn't actually indicate that the second column is the price, but I know that I downloaded only the share price and market value for each company. We can also see that there are a number of columns that Datastream failed to produce data for, showing up as #ERROR.\n\n## Dropping Invalid Columns\n\nThe first step is to remove the #ERROR columns. I do this using the dplyr::select_at() function, which allows me to search for character strings within column names. I redefine my dat object as the original dataframe, minus any column whose name contains \"ERROR.\"\n\n```{r}\ndat <- select_at(dat, vars(-starts_with(\"#ERROR\")))\n```\n\nWhile I'm at it, I'm going to rename the columns to all lowercase letters. Just for convenience, not necessary. I'm also going to change the name of the first column from name to date. dplyr::rename_all() is similar to dplyr::select_at(), except that I don't have to specify a rule for determining which columns to include, and I add the function that I want applied to all of the column names.\n\n```{r}\ndat <- dat %>% \n  rename_all(tolower) %>% \n  rename(date = name)\n```\n\nLet's take a look at the table now:\n\n```{r}\ndat\n```\n\nMuch better.\n\n## Reshaping\n\nNow that we've cleaned up the column names, we can move onto the real problem: the shape of the dataset. This is where tidyr comes in. tidyr provides functions to transform long tables into wide ones, and vice-versa. We currently have a dataset with a row for each day, and seaparate columns for each variable (share price and market value), grouped into companies. We want to end up with a dataset with a row for each company-day, and a column for each variable. That is, I want a column for date, a column for company, a column for price, and a column for market_value. The number of rows should equal the number of companies multipled by the number of unique days in the dataset. Here is my general approach:\n\n1.  Split the dataset into share price and market value tables\n2.  Convert both tables into \"long\" format\n3.  Join them back together by company name and date\n\n### Spliting the Data\n\nFirst, we need to split the dataset into two different tables, one for share price and one for market value.\n\n```{r}\nshare_price <- select_at(dat, vars(-ends_with(\"market value\")))\nmarket_value <- select_at(dat, vars(date, ends_with(\"value\")))\n```\n\nHere's the share_price table:\n\n```{r}\nshare_price\n```\n\nAnd the market_value table:\n\n```{r}\nmarket_value\n```\n\n### Lengthening the Tables\n\nNext, we use the tidyr::gather() function to turn the very wide tables into long ones.\n\n```{r}\nshare_price <- tidyr::gather(share_price, key = \"company\", value = \"share_price\", -date)\nmarket_value <- tidyr::gather(market_value, key = \"company\", value = \"market_value\", -date)\n```\n\ngather() takes a key argument, which is the name of the column in the new table that has all of the column names from the old table, and a value argument, which is the name of the column in the new table that actually contains the data. We also include -date to let the function know that we do not want the date field to be collapsed, we want it excluded from the operation.\n\nHere's the share_price data now:\n\n```{r}\nshare_price\n```\n\nAnd market_value:\n\n```{r}\nmarket_value\n```\n\nWhile I still have the data split, I'm going to clean up the company field in the market_value table so that it only has the company name.\n\n```{r}\nmarket_value <- mutate(market_value, company = gsub(\" - market value\", \"\", company))\nmarket_value\n```\n\n### Re-Combining\n\nNow all that's left is to join the tables back together. dplyr provides a number of \\_join() functions that mirror SQL joins, so the operation is pretty intuitive if you've worked with database tables.\n\n```{r}\nnew_data <- full_join(share_price, market_value, by = c(\"date\", \"company\"))\nnew_data\n```\n\nBeautiful.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","editor":"visual","theme":"cosmo","title-block-banner":false,"title":"Adventures in Data Cleaning","author":"Stephen Feagin","date":"2019-04-28","categories":["r","tidyverse","data cleaning"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}