{
  "hash": "904b193566c12a50a67238ecc5ce4791",
  "result": {
    "markdown": "---\ntitle: \"Project Euler: Sum Square Difference\"\nsubtitle: \"\"\nexcerpt: \"Find the difference between the square of the sum and the sum of the squares.\"\ndate: 2022-10-08\nauthor: \"Stephen Feagin\"\ndraft: false\nseries:\ntags:\n  - r\n  - project euler\n  - puzzle\ncategories:\nlayout: single # single or single-sidebar\n---\n\n\nProject Euler problem 6: Sum Square Difference. The brief reads:\n\n> The sum of the squares of the first ten natural numbers is,\n>\n> $$1^2 + 2^2 + ... + 10^2 = 385$$\n>\n> The square of the sum of the first ten natural numbers is,\n>\n> $$(1 + 2 + ... + 10)^2 = 3025$$\n>\n> Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640.\n>\n>Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.\n\n# Solution\n\nThe solution for R is actually very easy to do because of R's built-in math functions and out-of-the-box vectorization.\n\n### R\nR provides vectorization out of the box for many functions, and it's generally easy to apply it for functions that don't already have it. Vectorization in this case means the ability to natively apply a function to every value in a vector, rather than operating on the entire vector as its own object. In R, this is often executed in C or C++, which makes it *fast*. Much faster than writing a loop and iterating over every item in the vector.\n\nThis comes into play here because I can write `vec**2` to square every item in the vector, the same that I could write `4**2` to get 16. It doesn't matter that the input is a whole vector instead of a single number, R applies it quickly to every item. At that point, it's trivial to take the sum of the new vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- 1:100\nsum(vec)**2 - sum(vec**2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25164150\n```\n:::\n:::\n\n\n### Python\nIt's not quite as simple in Python, but still very straightforward. List comprehensions and generator expressions can do the same kind of things that vectorization do in R, and likewise very quickly.\n\n::: {.cell}\n\n```{.python .cell-code}\nseq = range(1, 101)  # We need to 1:100, not 0:99 which is what range(100) would give\nsum_of_squares = sum(i**2 for i in seq)\nsquare_of_sum = sum(seq)**2\nprint(square_of_sum - sum_of_squares)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n25164150\n```\n:::\n:::\n\n\n### Go\nOne of the strengths of Go is that is has very little magic. That means the code has to be more verbose because you do things manually.\n```go\n// For every number in the slice, add its square to a running total\nfunc sumOfSquares(nums []int) int {\n\ttotal := 0\n\tfor _, num := range nums {\n\t\ttotal += num * num\n\t}\n\treturn total\n}\n\n// Add every number in the slice to a running total, then\n// return the square of that total.\nfunc squareOfSums(nums []int) int {\n\ttotal := 0\n\tfor _, num := range nums {\n\t\ttotal += num\n\t}\n\treturn total * total\n}\n\nfunc main() {\n\t// Start by making the sequence of 1 to 100\n\tseq := make([]int, 100)\n\tfor i := 0; i < 100; i++ {\n\t\tseq[i] = i + 1\n\t}\n\t// Then take the difference between the two values\n\tfmt.Println(squareOfSums(seq) - sumOfSquares(seq))\n}\n```\n\nSee all of my Project Euler solutions on [GitHub](https://github.com/stephenfeagin/projecteuler).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}