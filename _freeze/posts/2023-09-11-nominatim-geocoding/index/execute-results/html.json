{
  "hash": "82c29a713bcc042cc0f1f0acc40af539",
  "result": {
    "markdown": "---\ntitle: Geocoding Addresses Using Nominatim and httr\ndate: 2023-09-11\ncategories:\n  - r\n  - httr2\n  - geospatial\n---\n\n\nI am interested in finding the latitude and longitude of a particular address. There are at least a few APIs that will do this for you, but I decided to use Nominatim as it is the one used on OpenStreetMap servers (https://wiki.openstreetmap.org/wiki/Geocoding), and I like OpenStreetMap. Nominatim has good [documentation](https://nominatim.org/release-docs/develop/api/Overview/) on the usage of their API. In order to make calls against this API, I will use the httr2 package. We need to compose our request, which in this case means crafting the search URL and specifying the output, and we also need to be able to parse the response object.\n\n## Building the Request URL\n\nThe Nominatim `/search` query takes the form `https://nominatim.openstreemap.org/search?<params>`. The documentation tells us that the query can either be free form or structured. For the free form query, you can essentially give it an address in natural language, ideally separated by commas. A structured query would provide the address having been split into its components, such as street, city, state, and postal code. A free form query would just have the entire address as the `q` param. We need to specify the format, which could be `xml`, `json`, `jsonv2`, `geojson`, or `geocodejson`. I am most interested in getting JSON results, so I'll use their `jsonv2`.\n\nI need to properly encode the URL. httr2 provides a `url_build()` function that will let me do this easily. I specify the format I want and limit it to only 1 result.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(httr2)\n\ncompose_url <- function(address) {\n  url <- url_parse(\"https://nominatim.openstreetmap.org/search\")\n  url$query <- list(q = address, format = \"jsonv2\", limit = 1)\n  url_build(url)\n}\n```\n:::\n\n\nTrying that with Chapel Hill Town Hall:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompose_url(\"405 Martin Luther King Jr. Blvd, Chapel Hill, NC 27514-5705\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"https://nominatim.openstreetmap.org/search?q=405%20Martin%20Luther%20King%20Jr.%20Blvd%2C%20Chapel%20Hill%2C%20NC%2027514-5705&format=jsonv2&limit=1\"\n```\n:::\n:::\n\n\n## Performing the Request \nNext, we use the httr2 package to send the API request. You may have to `install.packages(\"httr2\")` before attempting.\n\n\n::: {.cell}\n\n```{.r .cell-code}\naddress <- compose_url(\"405 Martin Luther King Jr. Blvd, Chapel Hill, NC 27514-5705\")\nreq <- request(address)\nreq\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n<httr2_request>\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nGET\nhttps://nominatim.openstreetmap.org/search?q=405%20Martin%20Luther%20King%20Jr.%20Blvd%2C%20Chapel%20Hill%2C%20NC%2027514-5705&format=jsonv2&limit=1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nBody: empty\n```\n:::\n:::\n\nWe can use `req_dry_run()` to see what the request will look like before we actually execute it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreq_dry_run(req)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGET /search?q=405%20Martin%20Luther%20King%20Jr.%20Blvd%2C%20Chapel%20Hill%2C%20NC%2027514-5705&format=jsonv2&limit=1 HTTP/1.1\nHost: nominatim.openstreetmap.org\nUser-Agent: httr2/0.2.3 r-curl/4.3.2 libcurl/7.81.0\nAccept: */*\nAccept-Encoding: deflate, gzip, br, zstd\n```\n:::\n:::\n\n\nThat looks fine. We could make it more specific by adding `Accept = \"application/json\"` but if you trust the API and its documentation (which is not always a given), it should be fine.\n\nLet's give it a try.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresp <- req_perform(req)\nresp\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n<httr2_response>\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nGET\nhttps://nominatim.openstreetmap.org/search?q=405%20Martin%20Luther%20King%20Jr.%20Blvd%2C%20Chapel%20Hill%2C%20NC%2027514-5705&format=jsonv2&limit=1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nStatus: 200 OK\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nContent-Type: application/json\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nBody: In memory (2 bytes)\n```\n:::\n:::\n\nLet's fetch the raw response:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresp_raw(resp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHTTP/1.1 200 OK\nserver: nginx\ndate: Mon, 11 Sep 2023 17:55:22 GMT\ncontent-type: application/json; charset=utf-8\ncontent-length: 2\n\n[]\n```\n:::\n:::\n\n\nWell that's not great. Let me try it with a different address:\n\n::: {.cell}\n\n```{.r .cell-code}\ncompose_url(\"1600 Pennsylvania Ave, Washington, DC 20500\") |> \n  request() |> \n  req_perform() |> \n  resp_raw()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHTTP/1.1 200 OK\nserver: nginx\ndate: Mon, 11 Sep 2023 17:55:23 GMT\ncontent-type: application/json; charset=utf-8\ncontent-length: 477\n\n[{\"place_id\":4252913,\"licence\":\"Data © OpenStreetMap contributors, ODbL 1.0. http://osm.org/copyright\",\"osm_type\":\"way\",\"osm_id\":899927559,\"lat\":\"38.8959025\",\"lon\":\"-77.0309076\",\"category\":\"highway\",\"type\":\"path\",\"place_rank\":27,\"importance\":0.07500999999999991,\"addresstype\":\"road\",\"name\":\"Pennsylvania Avenue\",\"display_name\":\"Pennsylvania Avenue, Washington, District of Columbia, 20045, United States\",\"boundingbox\":[\"38.8958906\",\"38.8959158\",\"-77.0309560\",\"-77.0308642\"]}]\n```\n:::\n:::\n\n\nThat one worked OK. What about my old dorm, Spencer Hall?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompose_url(\"100 Raleigh St, Chapel Hill, NC 27514\") |> \n  request() |> \n  req_perform() |> \n  resp_raw()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHTTP/1.1 200 OK\nserver: nginx\ndate: Mon, 11 Sep 2023 17:55:24 GMT\ncontent-type: application/json; charset=utf-8\ncontent-length: 587\n\n[{\"place_id\":926549,\"licence\":\"Data © OpenStreetMap contributors, ODbL 1.0. http://osm.org/copyright\",\"osm_type\":\"way\",\"osm_id\":44341299,\"lat\":\"35.914930999999996\",\"lon\":\"-79.0494403470627\",\"category\":\"building\",\"type\":\"dormitory\",\"place_rank\":30,\"importance\":9.99999999995449e-06,\"addresstype\":\"building\",\"name\":\"Spencer Residence Hall\",\"display_name\":\"Spencer Residence Hall, 100, Raleigh Street, Franklin-Rosemary Historic District, Baby Hollow, Chapel Hill, Orange County, North Carolina, 27514, United States\",\"boundingbox\":[\"35.9146468\",\"35.9152113\",\"-79.0495907\",\"-79.0491365\"]}]\n```\n:::\n:::\n\n\nThat one worked too.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompose_url(\"405 Martin Luther King Jr Blvd, Chapel Hill, NC 27514\") |> \n  request() |> \n  req_perform() |> \n  resp_raw()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHTTP/1.1 200 OK\nserver: nginx\ndate: Mon, 11 Sep 2023 17:55:24 GMT\ncontent-type: application/json; charset=utf-8\ncontent-length: 595\n\n[{\"place_id\":929037,\"licence\":\"Data © OpenStreetMap contributors, ODbL 1.0. http://osm.org/copyright\",\"osm_type\":\"way\",\"osm_id\":44340822,\"lat\":\"35.916585999999995\",\"lon\":\"-79.05738559583756\",\"category\":\"building\",\"type\":\"yes\",\"place_rank\":30,\"importance\":9.99999999995449e-06,\"addresstype\":\"building\",\"name\":\"Chapel Hill Town Hall\",\"display_name\":\"Chapel Hill Town Hall, 405, Martin Luther King Junior Boulevard, Franklin-Rosemary Historic District, Bolin, Chapel Hill, Orange County, North Carolina, 27516, United States\",\"boundingbox\":[\"35.9163479\",\"35.9168469\",\"-79.0575751\",\"-79.0570030\"]}]\n```\n:::\n:::\n\n\nI'm a bit puzzled here. It didn't work when I split out the steps but it seems to work when I connect it all in a pipeline. That gives me some concern over what might happen if I try to implement this on a large number of addresses; I worry that I may have to do a ton of spot-checking. I'm wondering if I can rewrite the `compose_url()` function to use the structured querying format, and see if that might help.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompose_url <- function(street, city, state, postcode = NA) {\n  url <- url_parse(\"https://nominatim.openstreetmap.org/search\")\n  params <- list(\n    street = street, \n    city = city, \n    state = state,\n    format = \"jsonv2\",\n    limit = 1\n  )\n  if (!is.na(postcode)) params$postcode <- postcode\n  url$query = params\n  url_build(url)\n}\n\naddress <- compose_url(\"405 Martin Luther King Jr Blvd\", \"Chapel Hill\", \"NC\", 27514)\nreq <- request(address)\nresp <- req_perform(req)\nresp_raw(resp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHTTP/1.1 200 OK\nserver: nginx\ndate: Mon, 11 Sep 2023 17:55:25 GMT\ncontent-type: application/json; charset=utf-8\ncontent-length: 595\n\n[{\"place_id\":929037,\"licence\":\"Data © OpenStreetMap contributors, ODbL 1.0. http://osm.org/copyright\",\"osm_type\":\"way\",\"osm_id\":44340822,\"lat\":\"35.916585999999995\",\"lon\":\"-79.05738559583756\",\"category\":\"building\",\"type\":\"yes\",\"place_rank\":30,\"importance\":9.99999999995449e-06,\"addresstype\":\"building\",\"name\":\"Chapel Hill Town Hall\",\"display_name\":\"Chapel Hill Town Hall, 405, Martin Luther King Junior Boulevard, Franklin-Rosemary Historic District, Bolin, Chapel Hill, Orange County, North Carolina, 27516, United States\",\"boundingbox\":[\"35.9163479\",\"35.9168469\",\"-79.0575751\",\"-79.0570030\"]}]\n```\n:::\n:::\n\nThat looks like it works, even with using intermediate objects. I really don't know why that didn't work before. Still not clear how it will fare with a large number of requests, but it would be easy enough to write code to check for empty result sets.\n\n## Examining the Output\n \nNow let's look at what httr can do to help us parse the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresp_body_json(resp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[[1]]$place_id\n[1] 929037\n\n[[1]]$licence\n[1] \"Data © OpenStreetMap contributors, ODbL 1.0. http://osm.org/copyright\"\n\n[[1]]$osm_type\n[1] \"way\"\n\n[[1]]$osm_id\n[1] 44340822\n\n[[1]]$lat\n[1] \"35.916585999999995\"\n\n[[1]]$lon\n[1] \"-79.05738559583756\"\n\n[[1]]$category\n[1] \"building\"\n\n[[1]]$type\n[1] \"yes\"\n\n[[1]]$place_rank\n[1] 30\n\n[[1]]$importance\n[1] 1e-05\n\n[[1]]$addresstype\n[1] \"building\"\n\n[[1]]$name\n[1] \"Chapel Hill Town Hall\"\n\n[[1]]$display_name\n[1] \"Chapel Hill Town Hall, 405, Martin Luther King Junior Boulevard, Franklin-Rosemary Historic District, Bolin, Chapel Hill, Orange County, North Carolina, 27516, United States\"\n\n[[1]]$boundingbox\n[[1]]$boundingbox[[1]]\n[1] \"35.9163479\"\n\n[[1]]$boundingbox[[2]]\n[1] \"35.9168469\"\n\n[[1]]$boundingbox[[3]]\n[1] \"-79.0575751\"\n\n[[1]]$boundingbox[[4]]\n[1] \"-79.0570030\"\n```\n:::\n:::\n\nThat's pretty verbose output, but the gist is that it creates a named list with the output data. What I'm most interested in is the latitude and longitude.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntown_hall <- resp_body_json(resp)\nc(town_hall[[1]]$lat, town_hall[[1]]$lon)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"35.916585999999995\" \"-79.05738559583756\"\n```\n:::\n:::\n\nNote that I have to subset the results with `[[1]]` because `resp_body_json()` returns a list of lists, one for each item in the json array. I specified `limit=1` but it still gave me back an array, just with only one item, so httr2 still reads that as a list of results, even if it's just one element long.\n\nLet's pull this up really quickly with leaflet:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(leaflet)\nmap <- leaflet() |> \n  addTiles() |> \n  addMarkers(\n    lng = as.numeric(town_hall[[1]]$lon),\n    lat = as.numeric(town_hall[[1]]$lat)\n  )\nmap\n```\n\n::: {.cell-output-display}\n```{=html}\n<div id=\"htmlwidget-8bf9ec7ac6b3c6d99433\" style=\"width:100%;height:464px;\" class=\"leaflet html-widget\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-8bf9ec7ac6b3c6d99433\">{\"x\":{\"options\":{\"crs\":{\"crsClass\":\"L.CRS.EPSG3857\",\"code\":null,\"proj4def\":null,\"projectedBounds\":null,\"options\":{}}},\"calls\":[{\"method\":\"addTiles\",\"args\":[\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",null,null,{\"minZoom\":0,\"maxZoom\":18,\"tileSize\":256,\"subdomains\":\"abc\",\"errorTileUrl\":\"\",\"tms\":false,\"noWrap\":false,\"zoomOffset\":0,\"zoomReverse\":false,\"opacity\":1,\"zIndex\":1,\"detectRetina\":false,\"attribution\":\"&copy; <a href=\\\"https://openstreetmap.org/copyright/\\\">OpenStreetMap<\\/a>,  <a href=\\\"https://opendatacommons.org/licenses/odbl/\\\">ODbL<\\/a>\"}]},{\"method\":\"addMarkers\",\"args\":[35.916586,-79.05738559583756,null,null,null,{\"interactive\":true,\"draggable\":false,\"keyboard\":true,\"title\":\"\",\"alt\":\"\",\"zIndexOffset\":0,\"opacity\":1,\"riseOnHover\":false,\"riseOffset\":250},null,null,null,null,null,{\"interactive\":false,\"permanent\":false,\"direction\":\"auto\",\"opacity\":1,\"offset\":[0,0],\"textsize\":\"10px\",\"textOnly\":false,\"className\":\"\",\"sticky\":true},null]}],\"limits\":{\"lat\":[35.916586,35.916586],\"lng\":[-79.05738559583756,-79.05738559583756]}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\n\nSo there we go, using httr and Nominatim to run some basic geocoding. I hope to use this in the future to work with open government data, a lot of which is geospatial.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/htmlwidgets-1.5.4/htmlwidgets.js\"></script>\n<script src=\"../../site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"../../site_libs/leaflet-1.3.1/leaflet.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/leaflet-1.3.1/leaflet.js\"></script>\n<link href=\"../../site_libs/leafletfix-1.0.0/leafletfix.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/proj4-2.6.2/proj4.min.js\"></script>\n<script src=\"../../site_libs/Proj4Leaflet-1.0.1/proj4leaflet.js\"></script>\n<link href=\"../../site_libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/leaflet-binding-2.2.0/leaflet.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}