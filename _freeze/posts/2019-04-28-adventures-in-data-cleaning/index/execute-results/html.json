{
  "hash": "5776cbbc42fd7c20259c1d4785655111",
  "result": {
    "markdown": "---\ntitle: Adventures in Data Cleaning\nauthor: Stephen Feagin\ndate: \"2019-04-28\"\ntags: [r, tidyverse, data cleaning]\n---\n\n\n\n\nI’m updating my first R-related blog post, from back in 2016. In it, I used reshape2 to do some data\ncleaning on a messy dataset. In this update, I’m going to use tools from the tidyverse instead. I’m\nkeeping most of the text the same, but changing the code chunks. As before, this is an R Markdown\nfile, so you can run the code along with me. You can find the data source \n[here](data/datastream_excerpt.xlsx).\n\nI’ve been working with stock market data, which has proven much less straightforward than I had\nexpected. Because the data I want is both cross-sectional and time-series — it uses daily data on\nmultiple values for multiple companies over a length of time — the raw data is an absolute mess. I\ngot the dataset from Thomson Reuters Datastream, which was a process in and of itself. So in this\npost, I’m just going to walk through the steps involved in cleaning the data into a workable data\nfile.\n\nThere are a couple of packages I’ll be using: readxl for reading in the Excel-formatted data, tidyr\nand dplyr for data cleaning, and here for dealing with filepaths in the website directoryt tree (you\nmay not need to deal with that, though). The only one that I want to import into the global\nnamespace is dplyr, because I only use the others once or twice.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n:::\n\n\n## Loading Data\n\nEasy enough:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilepath <- \"datastream_excerpt.xlsx\"\ndat <- readxl::read_excel(filepath)\n```\n:::\n\n\nLet’s see how that looks in its original format:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 23 × 21\n   Name                `ABBOTT LABS.(PAK.)` ABBOTT LABS.(PAK.) - …¹ `#ERROR...4`\n   <dttm>                             <dbl>                   <dbl> <chr>       \n 1 1999-04-12 00:00:00                 20.5                    920. $$ER: E100,…\n 2 1999-04-13 00:00:00                 20.5                    920. <NA>        \n 3 1999-04-14 00:00:00                 20.5                    920. <NA>        \n 4 1999-04-15 00:00:00                 20.5                    920. <NA>        \n 5 1999-04-16 00:00:00                 20.5                    920. <NA>        \n 6 1999-04-19 00:00:00                 20.5                    920. <NA>        \n 7 1999-04-20 00:00:00                 20.5                    920. <NA>        \n 8 1999-04-21 00:00:00                 20.5                    920. <NA>        \n 9 1999-04-22 00:00:00                 20.5                    920. <NA>        \n10 1999-04-23 00:00:00                 20.5                    920. <NA>        \n# ℹ 13 more rows\n# ℹ abbreviated name: ¹​`ABBOTT LABS.(PAK.) - MARKET VALUE`\n# ℹ 17 more variables: `#ERROR...5` <chr>, `ADAMJEE INSURANCE` <dbl>,\n#   `ADAMJEE INSURANCE - MARKET VALUE` <dbl>, `#ERROR...8` <chr>,\n#   `#ERROR...9` <chr>, `AGRIAUTO INDUSTRIES` <dbl>,\n#   `AGRIAUTO INDUSTRIES - MARKET VALUE` <dbl>, `#ERROR...12` <chr>,\n#   `#ERROR...13` <chr>, `#ERROR...14` <chr>, `#ERROR...15` <chr>, …\n```\n:::\n:::\n\n\nNone of these entries are entirely clear from just looking at the data. The first column, here\ncalled Name, is the numerical representation of the date for that entry. The second column gives us\nthe adjusted share price for the company Abbott Labs, and the third shows the market value. The\nspreadsheet doesn’t actually indicate that the second column is the price, but I know that I\ndownloaded only the share price and market value for each company. We can also see that there are a\nnumber of columns that Datastream failed to produce data for, showing up as #ERROR.\n\n## Dropping Invalid Columns\n\nThe first step is to remove the #ERROR columns. I do this using the dplyr::select_at() function,\nwhich allows me to search for character strings within column names. I redefine my dat object as the\noriginal dataframe, minus any column whose name contains “ERROR.”\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- select_at(dat, vars(-starts_with(\"#ERROR\")))\n```\n:::\n\n\nWhile I’m at it, I’m going to rename the columns to all lowercase letters. Just for convenience, not\nnecessary. I’m also going to change the name of the first column from name to date.\ndplyr::rename_all() is similar to dplyr::select_at(), except that I don’t have to specify a rule for\ndetermining which columns to include, and I add the function that I want applied to all of the\ncolumn names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- dat %>% \n  rename_all(tolower) %>% \n  rename(date = name)\n```\n:::\n\n\nLet’s take a look at the table now:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 23 × 11\n   date                `abbott labs.(pak.)` `abbott labs.(pak.) - market value`\n   <dttm>                             <dbl>                               <dbl>\n 1 1999-04-12 00:00:00                 20.5                                920.\n 2 1999-04-13 00:00:00                 20.5                                920.\n 3 1999-04-14 00:00:00                 20.5                                920.\n 4 1999-04-15 00:00:00                 20.5                                920.\n 5 1999-04-16 00:00:00                 20.5                                920.\n 6 1999-04-19 00:00:00                 20.5                                920.\n 7 1999-04-20 00:00:00                 20.5                                920.\n 8 1999-04-21 00:00:00                 20.5                                920.\n 9 1999-04-22 00:00:00                 20.5                                920.\n10 1999-04-23 00:00:00                 20.5                                920.\n# ℹ 13 more rows\n# ℹ 8 more variables: `adamjee insurance` <dbl>,\n#   `adamjee insurance - market value` <dbl>, `agriauto industries` <dbl>,\n#   `agriauto industries - market value` <dbl>, `al abid silk` <dbl>,\n#   `al abid silk - market value` <dbl>, `al-ghazi tractors` <dbl>,\n#   `al-ghazi tractors - market value` <dbl>\n```\n:::\n:::\n\n\nMuch better.\n\n## Reshaping\n\nNow that we’ve cleaned up the column names, we can move onto the real problem: the shape of the\ndataset. This is where tidyr comes in. tidyr provides functions to transform long tables into wide\nones, and vice-versa. We currently have a dataset with a row for each day, and seaparate columns for\neach variable (share price and market value), grouped into companies. We want to end up with a\ndataset with a row for each company-day, and a column for each variable. That is, I want a column\nfor date, a column for company, a column for price, and a column for market_value. The number of\nrows should equal the number of companies multipled by the number of unique days in the dataset.\nHere is my general approach:\n\n1. Split the dataset into share price and market value tables\n2. Convert both tables into “long” format\n3. Join them back together by company name and date\n\n### Spliting the Data\n\nFirst, we need to split the dataset into two different tables, one for share price and one for\nmarket value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshare_price <- select_at(dat, vars(-ends_with(\"market value\")))\nmarket_value <- select_at(dat, vars(date, ends_with(\"value\")))\n```\n:::\n\n\nHere’s the share_price table:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshare_price\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 23 × 6\n   date                `abbott labs.(pak.)` `adamjee insurance`\n   <dttm>                             <dbl>               <dbl>\n 1 1999-04-12 00:00:00                 20.5                4.99\n 2 1999-04-13 00:00:00                 20.5                5.12\n 3 1999-04-14 00:00:00                 20.5                5.23\n 4 1999-04-15 00:00:00                 20.5                5.25\n 5 1999-04-16 00:00:00                 20.5                5.32\n 6 1999-04-19 00:00:00                 20.5                6.02\n 7 1999-04-20 00:00:00                 20.5                6.41\n 8 1999-04-21 00:00:00                 20.5                6.25\n 9 1999-04-22 00:00:00                 20.5                6.18\n10 1999-04-23 00:00:00                 20.5                6.31\n# ℹ 13 more rows\n# ℹ 3 more variables: `agriauto industries` <dbl>, `al abid silk` <dbl>,\n#   `al-ghazi tractors` <dbl>\n```\n:::\n:::\n\n\nAnd the market_value table:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmarket_value\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 23 × 6\n   date                abbott labs.(pak.) - market valu…¹ adamjee insurance - …²\n   <dttm>                                           <dbl>                  <dbl>\n 1 1999-04-12 00:00:00                               920.                  2006.\n 2 1999-04-13 00:00:00                               920.                  2059.\n 3 1999-04-14 00:00:00                               920.                  2104.\n 4 1999-04-15 00:00:00                               920.                  2112.\n 5 1999-04-16 00:00:00                               920.                  2143.\n 6 1999-04-19 00:00:00                               920.                  2424.\n 7 1999-04-20 00:00:00                               920.                  2578.\n 8 1999-04-21 00:00:00                               920.                  2514.\n 9 1999-04-22 00:00:00                               920.                  2489.\n10 1999-04-23 00:00:00                               920.                  2539.\n# ℹ 13 more rows\n# ℹ abbreviated names: ¹​`abbott labs.(pak.) - market value`,\n#   ²​`adamjee insurance - market value`\n# ℹ 3 more variables: `agriauto industries - market value` <dbl>,\n#   `al abid silk - market value` <dbl>,\n#   `al-ghazi tractors - market value` <dbl>\n```\n:::\n:::\n\n\n### Lengthening the Tables\n\nNext, we use the tidyr::gather() function to turn the very wide tables into long ones.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshare_price <- tidyr::gather(share_price, key = \"company\", value = \"share_price\", -date)\nmarket_value <- tidyr::gather(market_value, key = \"company\", value = \"market_value\", -date)\n```\n:::\n\n\ngather() takes a key argument, which is the name of the column in the new table that has all of the\ncolumn names from the old table, and a value argument, which is the name of the column in the new\ntable that actually contains the data. We also include -date to let the function know that we do not\nwant the date field to be collapsed, we want it excluded from the operation.\n\nHere’s the share_price data now:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshare_price\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 115 × 3\n   date                company            share_price\n   <dttm>              <chr>                    <dbl>\n 1 1999-04-12 00:00:00 abbott labs.(pak.)        20.5\n 2 1999-04-13 00:00:00 abbott labs.(pak.)        20.5\n 3 1999-04-14 00:00:00 abbott labs.(pak.)        20.5\n 4 1999-04-15 00:00:00 abbott labs.(pak.)        20.5\n 5 1999-04-16 00:00:00 abbott labs.(pak.)        20.5\n 6 1999-04-19 00:00:00 abbott labs.(pak.)        20.5\n 7 1999-04-20 00:00:00 abbott labs.(pak.)        20.5\n 8 1999-04-21 00:00:00 abbott labs.(pak.)        20.5\n 9 1999-04-22 00:00:00 abbott labs.(pak.)        20.5\n10 1999-04-23 00:00:00 abbott labs.(pak.)        20.5\n# ℹ 105 more rows\n```\n:::\n:::\n\n\nAnd market_value:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmarket_value\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 115 × 3\n   date                company                           market_value\n   <dttm>              <chr>                                    <dbl>\n 1 1999-04-12 00:00:00 abbott labs.(pak.) - market value         920.\n 2 1999-04-13 00:00:00 abbott labs.(pak.) - market value         920.\n 3 1999-04-14 00:00:00 abbott labs.(pak.) - market value         920.\n 4 1999-04-15 00:00:00 abbott labs.(pak.) - market value         920.\n 5 1999-04-16 00:00:00 abbott labs.(pak.) - market value         920.\n 6 1999-04-19 00:00:00 abbott labs.(pak.) - market value         920.\n 7 1999-04-20 00:00:00 abbott labs.(pak.) - market value         920.\n 8 1999-04-21 00:00:00 abbott labs.(pak.) - market value         920.\n 9 1999-04-22 00:00:00 abbott labs.(pak.) - market value         920.\n10 1999-04-23 00:00:00 abbott labs.(pak.) - market value         920.\n# ℹ 105 more rows\n```\n:::\n:::\n\n\nWhile I still have the data split, I’m going to clean up the company field in the market_value table\nso that it only has the company name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmarket_value <- mutate(market_value, company = gsub(\" - market value\", \"\", company))\nmarket_value\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 115 × 3\n   date                company            market_value\n   <dttm>              <chr>                     <dbl>\n 1 1999-04-12 00:00:00 abbott labs.(pak.)         920.\n 2 1999-04-13 00:00:00 abbott labs.(pak.)         920.\n 3 1999-04-14 00:00:00 abbott labs.(pak.)         920.\n 4 1999-04-15 00:00:00 abbott labs.(pak.)         920.\n 5 1999-04-16 00:00:00 abbott labs.(pak.)         920.\n 6 1999-04-19 00:00:00 abbott labs.(pak.)         920.\n 7 1999-04-20 00:00:00 abbott labs.(pak.)         920.\n 8 1999-04-21 00:00:00 abbott labs.(pak.)         920.\n 9 1999-04-22 00:00:00 abbott labs.(pak.)         920.\n10 1999-04-23 00:00:00 abbott labs.(pak.)         920.\n# ℹ 105 more rows\n```\n:::\n:::\n\n\n### Re-Combining\n\nNow all that’s left is to join the tables back together. dplyr provides a number of _join()\nfunctions that mirror SQL joins, so the operation is pretty intuitive if you’ve worked with database\ntables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_data <- full_join(share_price, market_value, by = c(\"date\", \"company\"))\nnew_data\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 115 × 4\n   date                company            share_price market_value\n   <dttm>              <chr>                    <dbl>        <dbl>\n 1 1999-04-12 00:00:00 abbott labs.(pak.)        20.5         920.\n 2 1999-04-13 00:00:00 abbott labs.(pak.)        20.5         920.\n 3 1999-04-14 00:00:00 abbott labs.(pak.)        20.5         920.\n 4 1999-04-15 00:00:00 abbott labs.(pak.)        20.5         920.\n 5 1999-04-16 00:00:00 abbott labs.(pak.)        20.5         920.\n 6 1999-04-19 00:00:00 abbott labs.(pak.)        20.5         920.\n 7 1999-04-20 00:00:00 abbott labs.(pak.)        20.5         920.\n 8 1999-04-21 00:00:00 abbott labs.(pak.)        20.5         920.\n 9 1999-04-22 00:00:00 abbott labs.(pak.)        20.5         920.\n10 1999-04-23 00:00:00 abbott labs.(pak.)        20.5         920.\n# ℹ 105 more rows\n```\n:::\n:::\n\n\nBeautiful.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}